
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<!-- <title>  | Hselin</title> -->
	<title></title>

<meta name="author" content="Albert Chen"> 

<meta name="description" content="Inefficient and incompatible rules It is a truth universally acknowledged that Some of the Host Managed SMR rules are not exactly conducive to &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Hselin" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/images/favicon-32x32.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">Hselin</a></h1>
<h4></h4>
<nav id="main-nav"><ul>
  <li><a href="/about">About</a></li>
  <li><a href="/">Random Musings</a></li>
  <li><a href="/projects">Projects</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
  <li><a href="/about">About</a></li>
  <li><a href="/">Random Musings</a></li>
  <li><a href="/projects">Projects</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:hselin.github.io">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/10/06/keep-calm-and-break-rules/">
		
			Keep Calm and Break Rules</a>
	</h2>
	<div class="entry-content">
		<div style="overflow:auto">
  <b>Inefficient and incompatible rules</b>
  <br />
  <del>It is a truth universally acknowledged that</del> Some of the Host Managed SMR <a href="/blog/2015/09/29/keep-calm-and-follow-the-rules/">rules</a> are not exactly conducive to efficient I/O. Even worse, they are incompatible with current host side implementations. For example, a fresh drive with no written data will FAIL ALL read commands sent by the host as ZAC/ZBC does not allow host to read unwritten LBAs. However, this behavior impedes BIOS/OS&#8217; attempt to read partition table/disk signature during system initialization - resulting in either boot failure or long boot time (waiting for retries and timeouts).
  <br />
  <br />
  <b>Feedback and assumptions</b>
  <br />
  These situations occur when <del>storage vendors</del> we attempt to define protocols and heuristics without adequate and timely host side validation. By the time host side feedbacks are considered - firmware and hardware implementations have already ossified. Furthermore, sometimes storage standard authors <del>arrogantly</del> incorrectly assume that as long as a functionality is defined (in a standard), then operating systems should have already implemented support for it (e.g. ATA sense data reporting, SCT WRITE SAME). When reality hits assumption - we are left with inefficient and incompatible implementations.  
  <br />
  <br />
  <img class="" src="/images/posts/keep_calm_and_break_rules/keep_calm_and_break_rules.png" style="width: 30%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <b>Rules are meant to be broken</b>
  <br />
  Based on observations working with Host Managed SMR devices and conversations with fellow developers, here are some rules that we should consider breaking.
  <br />
  <br />
  <b>1. Allow read beyond zone Write Pointer, returning zeros or host specified data pattern for unwritten LBAs (similar to reading unmapped/trimmed sectors).</b>
  <br />
  <br />
  <img class="" src="/images/posts/keep_calm_and_break_rules/read_beyond_write_pointer.png" style="width: 45%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  This will allow current system initialization procedures to function without error and simplify host side implementation.
  <br />
  <br />
  <hr />
  <br />
  <b>2. Allow read/write operations to span zones.</b>
  <br />
  <br />
  <img class="" src="/images/posts/keep_calm_and_break_rules/read_and_write_spanning_zones.png" style="width: 80%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  This will eliminate the need to split I/Os along zone boundaries, thus increasing I/O efficiency and simplifying host side implementation (especially when there are <a href="https://lwn.net/Articles/637035/">multiple</a> zone sizes).
  <br />
  <br />
  <hr />
  <br />
  <b>3. Allow write commands addressed to zone starting LBA to implicitly reset zone Write Pointer.</b>
  <br />
  <br />
  <div style="text-align:center;">State of zone as write command is issued</div>
  <img class="" src="/images/posts/keep_calm_and_break_rules/implicit_zone_reset.png" style="width: 45%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <div style="text-align:center;">State of zone after write command is processed</div>
  <img class="" src="/images/posts/keep_calm_and_break_rules/implicit_zone_reset_result.png" style="width: 45%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  This is a potentially dangerous proposition - as a stray write could accidentally reset a zone and delete all its contents. However, this proposal will eliminate the need to send and wait for the completion of an extra reset Write Pointer command in the I/O path. Moreover, RESET WRITE POINTER EXT as defined currently in ZAC is a non-queued command, which cannot be mixed with NCQ commands (e.g. common read/write commands) without performance penalties.
  <br />
  <br />
  <hr />
  <br />
  <b>4. Allow write commands to start beyond zone Write Pointer, filling gap (unwritten LBAs) with zeros or host defined data pattern.</b>
  <br />
  <br />
  <div style="text-align:center;">State of zone as write command is issued</div>
  <img class="" src="/images/posts/keep_calm_and_break_rules/implicit_write_same.png" style="width: 45%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <div style="text-align:center;">State of zone after write command is processed</div>
  <img class="" src="/images/posts/keep_calm_and_break_rules/implicit_write_same_result.png" style="width: 45%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  This will eliminate the need for host to send unnecessary write commands just to advance the Write Pointer (so it could write to a specific LBA), leading to better performance and simpler implementation.
  <br />
  <br />
  <b>Conclusion</b>
  <br />
  As mentioned <a href="/blog/2015/08/26/another-layer-of-indirection/">previously</a> - SMR is not a “feature” that will directly benefit the end-user. The benefits of having SMR must greatly outweigh the cost of its adoption. It behooves the storage vendors to make the transition to SMR as easily and as efficiently possible.
</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-10-06T23:24:12-07:00" pubdate data-updated="true">Tuesday 10.06.15</time></div>
	


	
		<span class="comments"><a href="/blog/2015/10/06/keep-calm-and-break-rules//index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/09/29/keep-calm-and-follow-the-rules/">
		
			Keep Calm and Follow the Rules</a>
	</h2>
	<div class="entry-content">
		<div style="overflow:auto">
  <b>Accessing Host Managed SMR devices</b>
  <br />
  Host Managed SMR devices must be accessed using either Zoned Access (ATA) or Zoned Block (SCSI) command sets, which restrict I/O operations that could be sent from the host. This results in simplified device implementation and behavior - as we shifted the burden of shingled writing to host software. <del>Hopefully</del> It is expected, that the host will have access to more compute resources (e.g. memory) and semantic/system-level information than a low-level storage device.
  <br />
  <br />
  <img class="" src="/images/posts/keep_calm_and_follow_the_rules/keep_calm_and_follow_the_rules.png" style="width: 30%; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <b>Restrictions</b>
  <br />
  Below is a list of major I/O restrictions that ZAC and ZBC enforce on the host.
  <br />
  <span style="background: yellow;">Nonconforming I/O operations will be failed by the device.</span>
  <br />
  <br />
  <li>Sequential write - writes have to start at zone Write Pointer (WP)</li>
  <li>Zone WPs could be reset (to the zone&#8217;s starting LBA) by issuing a RESET WRITE POINTER command</li>
  <li>Writes have to be 4K aligned in SMR zones</li>
  <li>Reads cannot start or extend beyond the zone WP</li>
  <li>Read/Write commands cannot span zones (some exceptions may apply)</li>
  <br />
  Zone WPs are kept and maintained by the device, they are used to keep host write sequential so we don&#8217;t accidentally wipe-out already written data. After each successful write, the associated zone WP is advanced to the next &#8220;unwritten&#8221; location within the zone (i.e. largest LBA written + 1).
  <br /> 
  <br />
  Here are some concrete examples of the above I/O rules.
  <br />
  <br />
  <img class="" src="/images/posts/keep_calm_and_follow_the_rules/smr_rules.png" style="width: 100%; height: auto; display: block; margin-left: auto; margin-right: auto">  
  <br />
  1. <span style="color: red;">Not allowed - write commands cannot start before zone WP.</span>
  <br />
  2. <span style="color: green;">Allowed - write commands must start at zone WP.</span>
  <br />
  3. <span style="color: green;">Allowed - write commands must start and end in the same zone.</span>
  <br />
  4. <span style="color: red;">Not allowed - write commands cannot span multiple zones.</span>
  <br />
  5. <span style="color: red;">Not allowed - write commands cannot start after zone WP.</span>
  <br />
  6. <span style="color: green;">Allowed - read commands must start and end before zone WP.</span>
  <br />
  7. <span style="color: green;">Allowed - read commands can span up to LBA (zone WP - 1).</span>
  <br />
  8. <span style="color: red;">Not allowed - read commands cannot span multiple zones.</span>
  <br />
  9. <span style="color: red;">Not allowed - read commands cannot start on zone WP.</span>
  <br />
  10. <span style="color: red;">Not allowed - read commands cannot start after zone WP.</span>
  <br />
  <br />
  In the next <a href="/blog/2015/10/06/keep-calm-and-break-rules/">post</a> I&#8217;ll talk about why <span style="background: yellow;">we should break some of these rules for efficiency.</span>
</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-09-29T16:29:25-07:00" pubdate data-updated="true">Tuesday 09.29.15</time></div>
	


	
		<span class="comments"><a href="/blog/2015/09/29/keep-calm-and-follow-the-rules//index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/26/another-layer-of-indirection/">
		
			Another Layer of Indirection</a>
	</h2>
	<div class="entry-content">
		<div style="overflow:auto">
  <b>Introduction</b>
  <br />
  &#8220;Any problem in computer science can be solved by another layer of <a href="https://en.wikipedia.org/wiki/Indirection">indirection</a>&#8221;. Shingle Magnetic Recording (SMR) is no different - the only “difficulty” is in determining where to add the layer of indirection to enable maximum flexibility and efficiency. Basically, we want to insert a “SMR translation layer&#8221; that takes in random I/Os and outputs a sequential I/O stream. This layer could be implemented as a library, file system routine, driver, application or firmware - each with their own set of trade-offs. In general, higher indirection/abstraction layers will have access to more semantic and system level information. This could lead to better performance and more room for innovation. For example, the initiator application will have more knowledge about the importance and intent of an I/O than firmware on the target device.
  <br />
  <br />
  <img class="" src="/images/posts/smr_translation_layer.png" style="width: 350px; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <img class="" src="/images/posts/layers_of_information.png" style="width: 500px; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <b>Layers of SMR</b>
  <br />
  With these thoughts in mind, here are some approaches to enabling SMR.
  The orange boxes indicate where the “SMR translation layer&#8221; could be implemented for the various solutions. As one can see from the diagram below, where “SMR translation layer&#8221; could be inserted varies across the spectrum depending on the hardware and software deployed.
  <br />
  <br />
  <img class="" src="/images/posts/smr_stack.png" style="width: 500px; height: auto; display: block; margin-left: auto; margin-right: auto">
  <br />
  <br />
  <ul style="margin-top: 0px;">
    <li>
      <b>Enlightened user application</b>
      <br />
      Companies with system software engineering capabilities could develop or modify their applications to be SMR-aware and reap the benefits of increased capacity immediately without (much) ecosystem support. SMR awareness at this level enables great flexibility and efficiency as the application manages its own data allocation. However, it is not very scalable in terms of extending SMR support across all user applications. It also requires potential cooperation and co-development with SMR device manufacturers (e.g. error code propagation and interpretation).
    </li>
    <br />
    <li>
      <b>SMR software library</b>
      <br />
      Companies with moderate level of software engineering capabilities could develop or modify their applications to utilize libraries (e.g. <a href="https://github.com/hgst/libzbc">libzbc</a>) that provide SMR support. However, this requires modification of all applications that use SMR and ecosystem support (library development). It also introduces the complexity of dealing with library API changes.
    </li>
    <br />
    <li>
      <b>SMR-friendly file system</b>
      <br />
      Building a SMR-friendly file system is an attractive solution as it allows most applications to work with SMR devices without modification. The file system hides the complexity of SMR behind the familiar POSIX/Unix interface of open/close/read/write. At WD, we have <a href="/projects">modified</a> New Implementation of a Log-structured File System (NILFS) and Linear Tape File System (LTFS) to work with single and multi-zoned Host Managed SMR drives. However, file systems are notoriously hard to debug and to become trustworthy. It is also hard to convince people and companies to switch to a new file system just to support SMR devices. The situation may be different if major existing file systems become SMR-aware (e.g. <a href="https://github.com/Seagate/SMR_FS-EXT4">ext4</a>, <a href="https://git.kernel.org/cgit/fs/xfs/xfs-documentation.git/tree/design/xfs-smr-structure.asciidoc">XFS</a>, <a href="https://hackweek.suse.com/projects/282">BTRFS</a>, <a href="http://storageconference.us/2014/Presentations/Novak.pdf">ZFS</a>).
    </li>
    <br />
    <li>
      <b>SMR driver</b>
      <br />
      Further down the stack, we could build a SMR-aware block/filter driver. This allows file systems to work transparently with SMR devices and requires no application change. At WD, we are currently working on a <a href="https://en.wikipedia.org/wiki/Device_mapper">device mapper</a> target to support Host Managed SMR devices (more on this in later posts). However, SMR awareness at this level may not provide as much efficiency and flexibility as compared to some of the previous use models. Additionally, we may be constrained by functionalities and limitations of layers below (e.g. libATA, miniports).
    </li>
    <br />
    <li>
      <b>Device Managed SMR</b>
      <br />
      Finally, we could always punt the work of managing SMR behavior to the device. After all, device manufacturers are the storage experts and they &#8220;created&#8221; this problem in the first place! By implementing SMR handling at the lowest level, file systems and applications will work transparently with SMR devices - from the host perspective, a Device Managed SMR drive works exactly like a conventional <a href="https://en.wikipedia.org/wiki/Perpendicular_recording drive">PMR</a> drive. Have we found a panacea to our SMR problem? Maybe. It depends on our usage model and performance expectations. For example, just how &#8220;transparent&#8221; is this solution? Unlike traditional drives - the performance characteristics of a Device Managed SMR drive may change as we fill it to capacity (at some point read-modify-write will be required to change device contents). Can applications really transparently deal with this behavior? Furthermore, this &#8220;transparency&#8221; comes at a cost - in terms of performance, flexibility and scalability.
      <br />
      <br />
      <ul style="margin-top: 0px;">
        <li>
          Performance - at the device level, only limited amount of semantic information is available from the host. It is up to the device to interpret the meaning and importance of each read and write command. This limits the amount of optimization that could be implemented. For example, the device might kick off a garbage collection process while the host is busy flushing important data to disk; and an application can experience drastically different I/O completion times while executing the same operation.
        </li>
        <br />
        <li>
          Flexibility - since each vendor might implement SMR handling differently, device behavior and performance may differ by product line, manufacturer or even firmware version. For example, an I/O bound application might work as expected with a homogeneous drive population but exhibits unexpected behavior/bottlenecks when drive population is heterogeneous.
        </li>
        <br />
        <li>
          Scalability - the amount of <a href="https://en.wikipedia.org/wiki/Disk_buffer">memory</a> and processing power on each device is fixed at manufacturing time and specified by the storage vendor. This means the amount of resources available for SMR handling cannot be dynamically reallocated and scaled according to host software demand. This is important as storage devices are already (or are becoming increasingly) the bottleneck for many compute operations.
        </li>
      </ul>
    </li>
  </ul>
   Ultimately, there is no free lunch. Someone at some layer needs to pay the price for managing SMR. This can range from enlightened application down to enhanced firmware and through methods such as over-provisioning, usage of host resources, or <a href="https://en.wikipedia.org/wiki/Hybrid_drive">hybrid storage</a>. There is no one solution that fits all use cases - the additional layer of indirection for SMR is application and environment dependent.
  <br />
  <br />
  <b>Conclusion</b>
  <br />
  Fundamentally, SMR is not a &#8220;feature&#8221; for the end-user (unless you really want a <a href="https://en.wikipedia.org/wiki/Write_once_read_many">WORM</a> drive), it is a capacity enabler for device manufacturers. No user is willing to pay extra just to have SMR. The benefits of having SMR must greatly outweigh the cost of its adoption for us to see significant espousal in developing and modifying software and hardware to be SMR-aware/friendly. As we&#8217;ve seen, SMR adoption is a complex problem. It cannot be solved by a single vendor or in a single layer; it requires the whole ecosystem to work together to build a comprehensive solution for all use cases.
</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-08-26T23:58:11-07:00" pubdate data-updated="true">Wednesday 08.26.15</time></div>
	


	
		<span class="comments"><a href="/blog/2015/08/26/another-layer-of-indirection//index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/08/23/host-managed-smr-simulator/">
		
			Host Managed SMR Simulator</a>
	</h2>
	<div class="entry-content">
		<div style="overflow:auto">
  <b>Introduction</b>
  <br />
  <a href="https://en.wikipedia.org/wiki/Shingled_magnetic_recording">Shingle Magnetic Recording</a> is a disruptive technology that will enable areal density growth for the hard drive industry by partially overlapping tracks. Shingling requires physical writes to be sequential, which opens the question of how to address this behavior at a system level. Two general approaches contemplated are to either handle block management in the device (Device Managed SMR) or in host software (Host Managed SMR) via Zone ATA or Zoned Block command sets (ZAC/ZBC).
  <br />
  <br />
  <b>Trade-offs between Host Managed and Device Managed solutions</b>
  <br />
  There are trade-offs to each approach. For example, Device Managed SMR drives are backwards compatible with existing file systems and BIOS&#8217; but may introduce unpredictable or uncontrollable performance. While Host Managed SMR drives provide and suffer the opposite.
  <br />
  <br />
  <b>Host Managed SMR protocol constraints</b>
  <br />
  ZBC and ZAC protocols restrict what IOs could be sent to the device and this in turn simplifies HW/FW behavior and implementation. Major differences/restrictions include:
  <br/>
  <ul style="margin-top: 0px;">
    <li>New device type (may not work with existing OS/HBA/BIOS)</li>
    <li>Sequential write - writes have to start at zone Write Pointer</li>
    <li>Writes have to be 4k aligned in SMR zones</li>
    <li>Reads cannot start or extend beyond the zone Write Pointer</li>
    <li>Read/Write commands cannot span zones (some exceptions may apply)</li>
  </ul>
  <b>Host Managed SMR device simulator</b>
  <br />
  This week, WD is releasing a SMR simulator to facilitate host-side software/file system development.
  SMR-Simulator is a simple tool that captures host software behavior and determines its “friendliness” to SMR technology. We hope SMR-Simulator will enable open source developers to experiment and become familiar with SMR functionalities and behaviors without the need to access real SMR (ZBC/ZAC) HW.
  <br />
  <br />
  <b>Web site</b>
  <br />
  <a href="https://github.com/westerndigitalcorporation/SMR-Simulator">https://github.com/westerndigitalcorporation/SMR-Simulator</a>
  <br />
  <b>Behavior expectations</b>
  <br />
  <a href="https://github.com/westerndigitalcorporation/SMR-Simulator/wiki/SMR-Simulator-Behavior-Expectations">https://github.com/westerndigitalcorporation/SMR-Simulator/wiki/SMR-Simulator-Behavior-Expectations</a>
  <br />
  <br />
  <img class="float-left" src="/images/posts/magnetic_pole.png" style="width: 300px; height: auto;">
</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-08-23T11:37:24-07:00" pubdate data-updated="true">Sunday 08.23.15</time></div>
	


	
		<span class="comments"><a href="/blog/2015/08/23/host-managed-smr-simulator//index.html#disqus_thread">Comments</a></span>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/27/iot-security/">
		
			IoT Security</a>
	</h2>
	<div class="entry-content">
		<div style="overflow:auto">
  Course presentation for <a href="http://cs294s.stanford.edu">CS 294S: Research Project in Software Systems and Security</a>. 
  <br />
  <br />
  <b>Introduction</b>
  <br />
  Growth of IoT is phenomenal. More and more devices are becoming connected. This also means a bigger attack surface and real life-threatening consequences in a security breach. 
  <br />
  <iframe src="https://docs.google.com/presentation/d/1QP_UmcL-H6H5zTwYkXBoWcxrkyLfvdvht2SzhIx3kPA/embed?start=false&loop=false&delayms=0" frameborder="0" width="480" height="299" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
  <br />
  <b>This is awesome</b>
  <br />
  &#8220;Homomorphic encryption is a form of encryption that allows computations to be carried out on <span style="font-weight: bold; color:red;">ciphertext</span>, thus generating an encrypted result which, when decrypted, matches the result of operations performed on the plaintext.&#8221;
  <a href="https://en.wikipedia.org/wiki/Homomorphic_encryption/">https://en.wikipedia.org/wiki/Homomorphic_encryption</a>
</div>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-06-27T13:09:00-07:00" pubdate data-updated="true">Saturday 06.27.15</time></div>
	


	
		<span class="comments"><a href="/blog/2015/06/27/iot-security//index.html#disqus_thread">Comments</a></span>
	
</div></article>

<nav id="pagenavi">
    
    
        <a href="/2" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Albert Chen

</footer>
	<script src="/javascripts/slash.js">
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'hselin';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>
